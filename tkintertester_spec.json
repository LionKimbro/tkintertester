{
  "document": {
    "document_id": "tkintertester.spec.v0.1",
    "title": "tkintertester Specification",
    "purpose": "specify tkintertester -- a minimal, event-loop-native test harness for Tkinter GUI applications without async"
  },
  "spec_metadata": {
    "name": "tkintertester",
    "document_id": "tkintertester.spec.v0.1",
    "version": "0.1",
    "author": "Lion Kimbro",
    "purpose": "A minimal, event-loop-native test harness for Tkinter GUI applications without async.",
    "design_principles": [
      "Single Tk mainloop per process",
      "All tests run in a single process on a single thread.",
      "No async/await",
      "No classes",
      "No use of the Python 'global' keyword",
      "All scalar mutable state stored in a single G dictionary",
      "Tests execute inside the real Tk event loop",
      "Step-based execution driven by return values",
      "Harness does not own or track application widgets"
    ]
  },
  "module_structure": {
    "harness_module": {
      "filename": "harness.py",
      "responsibility": "Owns test execution, scheduling, timeouts, and result recording. Does not own application widgets."
    },
    "application_module": {
      "responsibility": "Owns application lifecycle (creation & destruction) via entry and exit functions.",
      "code": "g = {\n  \"entry\": None,  # nullary fn, called when the program \"begins\" (will create Toplevel, widgets, etc., -- setting basica app setup for a test\n  \"exit\": None  # nullary fn, will delete all Toplevels, conclude basic app teardown at the end of a test\n}\n"
    },
    "test_module": {
      "responsibility": "Defines tests, steps, and any helper functions for interacting with widgets."
    }
  },
  "global_state_model": {
    "tests": {
      "type": "list",
      "location": "module-level (outside G)",
      "description": "Ordered list of test dictionaries. Never rebound and never mutated or consumed by the harness during execution; contents may be updated with results."
    },
    "G": {
      "type": "dict",
      "location": "harness module",
      "description": "Container for all scalar mutable global state required by the harness.",
      "keys": {
        "root": {
          "type": "tk.Tk",
          "description": "Hidden Tk root window. Created once and immediately withdrawn."
        },
        "current_test": {
          "type": "dict | null",
          "description": "Reference to the currently executing test dictionary; None when execution is finished."
        },
        "current_step_index": {
          "type": "int",
          "description": "Index of the currently executing step within the current test."
        },
        "test_done": {
          "type": "bool",
          "description": "Flag indicating the current test has completed (success or failure)."
        },
        "current_timeout_after_id": {
          "type": "str | null",
          "description": "Tk after() identifier for the currently scheduled timeout callback."
        },
        "start_time": {
          "type": "float | null",
          "description": "Timestamp marking the start of the current test execution."
        }
      }
    }
  },
  "test_data_model": {
    "test_object": {
      "type": "dict",
      "required_keys": {
        "title": {
          "type": "string",
          "description": "Human-readable name of the test."
        },
        "steps": {
          "type": "list",
          "description": "Ordered list of step functions (nullary callables)."
        }
      },
      "result_keys": {
        "status": {
          "type": "string | null",
          "allowed_values": [
            "success",
            "fail",
            "timeout",
            null
          ],
          "description": "Final outcome of the test."
        },
        "fail_message": {
          "type": "string | null",
          "description": "Human-readable failure reason, if any."
        },
        "exception": {
          "type": "string | null",
          "description": "Captured exception traceback, if any."
        }
      }
    }
  },
  "step_function_contract": {
    "signature": "step() -> (action, value)",
    "description": "Each step is a nullary function invoked by the harness.  It returns a tuple describing how execution should proceed.  Step functions must not block; they must return control to the Tk event loop on every invocation.",
    "return_actions": {
      "next": {
        "value": "None | int",
        "meaning": [
          "If value is None: advance immediately to the next step.",
          "If value is int: advance to the next step after value milliseconds."
        ]
      },
      "wait": {
        "value": "int",
        "meaning": "Repeat the same step after value milliseconds."
      },
      "fail": {
        "value": "string",
        "meaning": "Fail the test immediately with the given reason."
      },
      "success": {
        "value": "None | int",
        "meaning": [
          "Declare the test successful immediately.",
          "If value is int: delay finalization by value milliseconds."
        ]
      }
    },
    "default_completion_rule": "If all steps are exhausted without an explicit 'success' or 'fail', the test is considered successful."
  },
  "execution_model": {
    "overview": [
      "Harness creates hidden Tk root and enters mainloop once.",
      "Tests are executed sequentially.",
      "The tests list is never mutated or consumed during execution; progression is tracked via G.current_test.",
      "Each test runs as a state machine driven by step return values.",
      "All scheduling is done via root.after().",
      "Timeouts are enforced per test."
    ],
    "lifecycle": [
      "Initialize G and hidden root",
      "Advance to the next test by updating G.current_test, and reset execution state.",
      "Invoke application entry function",
      "Execute steps until success, failure, or timeout",
      "Record results into the test object",
      "Invoke application exit function",
      "Proceed to next test or exit mainloop"
    ]
  },
  "minimal_step_executor": {
    "description": "Core logic that interprets step return values and schedules the next action via the Tk event loop.",
    "pseudocode": [
      "call current step function",
      "if return action is 'fail':",
      "  mark test failed; set G.test_done",
      "elif return action is 'success':",
      "  mark test successful; set G.test_done (optionally delayed)",
      "elif return action is 'next':",
      "  increment step index",
      "  if delay specified: schedule next step after delay",
      "  else: execute next step immediately",
      "elif return action is 'wait':",
      "  schedule same step after specified delay",
      "if no steps remain:",
      "  mark test successful"
    ]
  },
  "timeout_handling": {
    "model": "Single active timeout per test",
    "mechanism": [
      "Schedule timeout callback via root.after(timeout_ms)",
      "Store returned after_id in G.current_timeout_after_id",
      "Cancel timeout on test completion",
      "On timeout: mark test as failed with status 'timeout'"
    ]
  },
  "test_authoring_helpers": {
    "add_test": {
      "name": "add_test",
      "purpose": "Constructs a test dictionary conforming to the test data model and registers it by appending it to the global tests list.",
      "signature": "add_test(title, steps) -> None",
      "arguments": {
        "title": {
          "type": "string",
          "description": "Human-readable name of the test."
        },
        "steps": {
          "type": "list",
          "description": "Ordered list of step functions (nullary callables) defining the test behavior."
        }
      },
      "behavior": [
        "Creates a new test dictionary with required keys.",
        "Initializes result fields (status, fail_message, exception) to null.",
        "Appends the test dictionary to the global tests list.",
        "Does not return a value."
      ],
      "notes": [
        "The tests list is never mutated or consumed by the harness during execution.",
        "The steps list is defensively copied when constructing the test object."
      ]
    }
  },
  "non_goals": [
    "Harness does not discover widgets",
    "Harness does not simulate OS-level input",
    "Harness does not provide test authoring helpers in v0.1",
    "Harness does not integrate directly with pytest",
    "Use of async/await or coroutine-based control flow",
    "Class-based harness design"
  ],
  "future_extensions": [
    "Optional test authoring helpers (click, type, assert_text)",
    "Optional widget registry conventions",
    "pytest integration wrapper",
    "Structured logging and reporting",
    "Parallel test execution (not recommended for Tk)"
  ]
}
